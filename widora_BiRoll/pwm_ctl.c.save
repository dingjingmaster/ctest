/*------------------------------------------------------------------
PWM driver Based on:
Author: qianrushizaixian
refer to:  blog.csdn.net/qianrushizaixian/article/details/46536005

--- TODOs & BUGs ---
1. the motor will get stuck when starting pwm_threshold is too small. 
  --- use ACTIVATE_EMERG_STOP to prevent it.
2.

Midas
------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <math.h> //-- -lm
#include <stdbool.h> //bool
#include "pinctl.h"
//#include <pthread.h>

#include "/home/midas/ctest/kmods/soopwm/sooall_pwm.h"
#define PWM_DEV "/dev/sooall_pwm"

int main(int argc, char *argv[])
{
	int ret = -1;
	int pwm_fd;
	int pwmno;
	int delt;
	int pwm_width; // +-400fastest ~ 0 standstill 
	struct pwm_cfg  cfg;
	int tmp;

	//---- prepare pins for MOTOR direction and emergency stop control --------
	Prepare_CtlPins();
	SET_MOTOR_BRAKE;

	//--- open pwm dev ----
	pwm_fd = open(PWM_DEV, O_RDWR);
	if (pwm_fd < 0) {
		printf("open pwm fd failed\n");
		return -1;
	}

	//---- pwm configuration -------
	cfg.no        =   0;    /* pwm0 */
	cfg.clksrc    =   PWM_CLK_40MHZ; //40MHZ or 100KHZ; 20-30KHZ for NIDEC24H PWM control
	cfg.clkdiv    =   PWM_CLK_DIV4; //DIV4 for 25KHz,40us  //DIV2 40/2=20MHZ
	cfg.old_pwm_mode =false;    /* true=old mode --- false=new mode */
	cfg.stop_bitpos = 63; // stop position of send data 0-63
	cfg.idelval   =   0;
	cfg.guardval  =   0; //
	cfg.guarddur  =   0; //
	cfg.wavenum   =   0;  /* forever loop */
	cfg.datawidth =   400;// for 25KHZ,40us;  //--limit 2^13-1=8191 
	cfg.threshold =   0; //(0-400)for PWM adjust
	//---period=1000/100(KHZ)*(DIV(1-128))*datawidth   (us)
	//---period=1000/40(MHz)*(DIV)*datawidth       (ns)
	//MOTOR PWM 25KHz:  40,000ns = 1000/40*DIV4*datawidth400 (ns), so threshole adjustable: 0-400

	//------ set PWM_MODE as OLD -----
	cfg.old_pwm_mode=true;

	//---print corresponding period---
	if(cfg.old_pwm_mode == true)
	{
           if(cfg.clksrc == PWM_CLK_100KHZ)
		{
			tmp=pow(2.0,(float)(cfg.clkdiv));
			printf("tmp=%d,set PWM period=%d us\n",tmp,(int)(1000.0/100.0*tmp*(int)(cfg.datawidth))); // div by integer is dangerous!!!
		}
           else if(cfg.clksrc == PWM_CLK_40MHZ)
		{
			tmp=pow(2.0,(float)(cfg.clkdiv));
			printf("tmp=%d,set PWM period=%d ns\n",tmp,(int)(1000.0/40.0*tmp*(int)(cfg.datawidth))); // div by integer is dangerous!!!
		}
         }
	else if(cfg.old_pwm_mode == false)
	{
		printf("senddata0= %#08x  senddata1= %#08x \n",cfg.senddata0,cfg.senddata1); 
	}

	//----first set configure, then enable pwm -----
	cfg.no        =   0;    /* pwm0 */
	ioctl(pwm_fd, PWM_CONFIGURE, &cfg);
	cfg.no        =   1;    /* pwm1 */
	ioctl(pwm_fd, PWM_CONFIGURE, &cfg);


/*------------  test PWM for MOTOR ------------------
1. DC geared motor, speed controled by voltage only.
	Rated voltage: 3V-6V
2. DC motr driver mode L298.
	Applicable threshold 0(fast) ~ 150(slowest)


----------------------------------------------------*/
	pwm_width=0;  //start speed
	cfg.threshold = 0;
 	delt=1;
        while(1){
		usleep(15000);

		if(cfg.threshold == 150)
		{
			delt=-1;
			SET_MOTOR_FORWARD;
		}
		if(cfg.threshold == 0)
		{
			delt=1;
			SET_MOTOR_REVERSE;
		}

		cfg.threshold += delt;


		printf("cfg.threshold = %d \n",cfg.threshold);
		cfg.no        =   0;    /* pwm0 */
		ioctl(pwm_fd, PWM_CONFIGURE, &cfg);
		cfg.no        =   1;    /* pwm1 */
		ioctl(pwm_fd, PWM_CONFIGURE, &cfg);
	} //while

	//----- close pwm dev fd -----
	close(pwm_fd);
	//--- close all sock fds.......
	//----- release pin mmap ----
	Release_CtlPints();

	return 0;
}
